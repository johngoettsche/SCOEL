#  
#  srccode.icn
#  Handles the collected globla names from the loaded executable (binary).
#  It collects and filters names generated by the globalnames() 
#  Author : Ziad Al-Sharif
#  Date   : Oct 13, 2008
#  e-mail : zsharif@gmail.com
# 

#
# This packages is used by the analyzeGlobalNames()
# to identify each package classes and procedures
#
record PackageInfo(
   classes,  # a set with all class names used in that package,
             # it is a subset of the general classes set, which 
             # can be used in the methods table 
   procs,    # a set with all procedures used in that package
   vars      # a set with all global variables in that package
   )

#
# This class handles the global names in the source code,
# names that are dicovered by the globalnames() premitive at
# the start of the program (executable)
#
class SourceCode(
   vglobals,  # a set of all global variable names
   pglobals,  # a set of all user-defined procedure names used in program
   fglobals,  # a set of all built-in function names used in program
   records,   # a set of all the user defined records
   classes,   # a set of all the user defined classes
   methods,   # a table maps each class name into its set of methods
   packages,  # a table maps each package name into its set procedures
   pkgclasses # a set of all classes that are member of a package
   )

#
# public method:
# This method analyzes the names discovered by globalnames()
# and built sets of all:
# 1) package names,  2) global variables, 3) procedure names, 
# 4) function names, 5) record names , 6) class names, and
# 7) method names
#
method analyzeGlobalNames()
   local var, pkg, img, x, i, j

   every x := globalnames(Monitored) do{
     # globalnames() keeps a reference for strings in the icode
     # This is very bad for multiple loaded programs
     # So, this image() thing takes care of the problem by
     # allocating a new string in the string region. 
     x := image(x)[2:-1]
     var := variable(x, Monitored)
     img := image(var)
     if find("procedure", img) then{
        insert(pglobals, img[11:0])
        }
     else if find("function", img) then{
        insert(fglobals, img[10:0])
        }
     else if find("record constructor", img) then{
        if i := find("__state"|"__methods", x) then{
           # at this point we may have a package
           # I do not think at thei point we support nested packages
           if (j := find("__", x)) & j ~= i then{
              pkg := x[1:j]
              /packages[pkg] := PackageInfo()
              /packages[pkg].classes := set()
              insert(packages[pkg].classes, x[j+2:i])
              insert(pkgclasses, x[j+2:i])
              }
           else{
              insert(classes,  x[1:i])
              } 
           } 
        else
           insert(records, x)
        }
     else if not find("__oprec",x) then
        insert(vglobals, x)
     }
    
     removeClassRecordConstructor()
     filterPackages()
     filterMethods()
end

#
# private method:
# This method removes the class record constructor from the
# set of procedures: pglobals
#
method removeClassRecordConstructor()
   local cname
   
   every cname := !classes do{
     if member(pglobals,cname) then
        delete(pglobals,cname)
     if member(pglobals,cname||"initialize") then
        delete(pglobals,cname||"initialize")
     }
end

#
# private method:
# This methods filters the collected packages
#
method filterPackages()
   local pkg, pkgcls, pname, cname, vname, x, i, j

   every pkg := key(packages) do{
     x := pkg || "__"
     # filter package procedures out of the pglobals 
     every pname := !pglobals do{
       if match(x, pname) then{
          i := *x + 1
          # ignore packageName__className() procedure
          # and    packageName__classNameinitialize() procedure 
          if j := find("_",pname[i:0]) - 1 then{
             cname := pname[i+:j]
             if member(pkgclasses, cname) then{
                pkgcls := pname[1:j]
                /methods[cname] := set()
                insert(methods[cname], pname)
                delete(pglobals, pname) 
                }
             else{
                /packages[pkg] := PackageInfo()
                /packages[pkg].procs := set()
                insert(packages[pkg].procs, pname)
                delete(pglobals, pname) 
                }
             }
          else
             delete(pglobals, pname)
          }
       }
     # filter package global variables out of the vglobals 
     every vname := !vglobals do{
       if match(x, vname) then{
          i := *x + 1
          /packages[pkg] := PackageInfo()
          /packages[pkg].vars := set()
          insert(packages[pkg].vars, vname)
          delete(vglobals, vname) 
          }
       }
     }
end
   
#
# private method:
# This method filters class methods from the procedures
# 
method filterMethods()
   local cls, cname, pname, x

   # move methods from the procedure set to the methods table
   cls := classes ++ pkgclasses
   every cname := !cls do{
     x := cname || "_"
     every pname := !pglobals do
       if match(x, pname) then{
          delete(pglobals, pname)
          /methods[cname] := set()
          insert(methods[cname],pname)
          }
     }
end

#
# public method:
# This method succeeds if name is a built-in used in this program
#
method isFunction(name)

   if member(fglobals, name) then 
      return
   fail
end

#
# public method:
# This method succeeds if name is a procedure used in this program
#
method isProcedure(name)

   if member(pglobals, name) then 
      return
   fail
end

#
# public method
# checks if a prcedure is in the stack or not
#
method isActiveProc(pname)
   local level, p, j, i:=0
  
   level := keyword("level", Monitored)
   while i <= level do{
      p := image(proc(Monitored, i))
      if j := find(" ",p)+1 then{
         p := p[j:0]
         if p == pname then
            return i
         }
      else fail
      i +:= 1
      }
   fail
end

#
# public method
# checks wheather name is a local one
#
method isLocal(name, level)
   local x

   /level := 0
   every x := localnames(Monitored, level) do
      if x == name then
         return
   fail
end

#
# public method
# checks wheather name is a parameter
#
method isParam(name, level)
   local x

   /level := 0
   every x := paramnames(Monitored, level) do
      if x == name then
         return
   fail
end

# 
# public method
# checks wheather name is a local one
#
method isStatic(name, level)
   local x

   /level := 0
   every x := staticnames(Monitored, level) do
      if x == name then
         return
   fail
end

#
# public method:
# This method succeeds if name is a global var used in this program
#
method isGlobal(name)

   if member(vglobals, name) then 
      return
   fail
end

#
# public method:
# This method succeeds if name is a package used in this program
#
method isPackage(name)

   if \packages[name] then 
      return
   fail
end

#
# public method:
# This method succeeds if name is a class name used in this program
#
method isClass(name)

   if member(classes, name) | member(pkgclasses, name) then 
      return
   fail
end

#
# public method:
# This method succeeds if name is a method used in this program
# and it returns it class name; the m_name = "cls_method"
#
method isMethod(m_name, c_name)
   local mthd, cls, i

   #every cls := key(methods) do{
   #   every m := !methods[cls] do 
   #      write(cls,"_",m)
   #   write("--------OK")
   #   }

   if /c_name then{
      if i := find("_",m_name) then
         cls  := m_name[1:i]

      if isClass(cls) & member(methods[cls], m_name)  then
         return
      else{
         every cls := key(methods) do
            if \methods[cls] & member(methods[cls], m_name) then 
               return cls
         fail
         }
      }
   else{
      if isClass(c_name) then{
         mthd := c_name||"_"||m_name            
         if \methods[c_name] & member(methods[c_name], mthd) then
            return cls
         fail
         }
      }
  fail
end

#
# public method:
# This method succeeds if name is a record used in this program
#
method isRecord(name)

   if member(records, name) then 
      return
   fail
end

# public method:
# This method returns a list of package names used in the loaded program
#
method getPackages()
   local pkg, names := []

   if *packages > 0 then{
      every pkg := key(packages) do
        push(names, pkg)
      return sortf(names)
      }
   else
      fail
end

#
# public method:
# returns a list of the class names used in that package
# or returns a list of all class names used in all packages
#
method getPackageClasses(pkg)
   local cname, names := []

   if \pkg then{
      if \packages[pkg] & \packages[pkg].classes then
         every cname := !packages[pkg].classes do
           push(names, cname)
      }
   else{
      if *pkgclasses > 0 then
         every cname := !pkgclasses do
           push(names, cname)
      }
   return names
end

#
# public method:
# returns the total number of classes used in a package
# or returns the total number of class used in all packages
#
method getTotalPackageClasses(pkg)
   local total:=0

   if \pkg then{
      total := if \packages[pkg].classes then *packages[pkg].classes
      }
   else{
      total := *pkgclasses     
      }
   return total
end

#
# public method:
# returns a list of all procedure names used in a package,
# or returns a list of all procedure names used in all packages
#
method getPackageProcs(pkg)
   local p, k, i, names := []

   if \pkg then{
      if \packages[pkg] & \packages[pkg].procs then{
         i := *pkg + 3 # (1 + 2)
         every p := !packages[pkg].procs do
           push(names, p[i:0])
         }
      }
   else{
      every k := key(packages) do
        if \packages[k].procs then{
           every p := !packages[k].procs do
             push(names, p[i:0])
           }
      }
   return names
end

#
# public method:
# returns the total number of procedures in a package,
# or returns the total number of procedures in all packages.
#
method getTotalPackageProcs(pkg)
   local k, total:=0
   
   if \pkg then{
     total := if \packages[pkg].procs then *packages[pkg].procs
     }
   else{ 
     every k := key(packages) do
        if \packages[k].procs then 
           total +:= *packages[k].procs
     }
   return total 
end

#
# public method:
# returns a list of all global variables in that package
# or returns a list of all global variables in all packages
#
method getPackageVars(pkg)
   local var, k, i, names := []
   
   if \pkg then{
      if \packages[pkg] & \packages[pkg].vars then{
         i := *pkg + 3 # (1 + 2)
         every var := !packages[pkg].vars do
           push(names, var[i:0])
         }
      }
   else{
      every k := key(packages) do
        if \packages[k].vars then
           every var := !packages[k].vars do
             push(names, var[i:0])
      }  
   return names
end

#
# public method:
# returns the total number of global variables in a package
# or returns the total number of global variables in all packages
#
method getTotalPackageVars(pkg)
   local k, total:=0
   
   if \pkg then{
      total := if \packages[pkg].vars then *packages[pkg].vars
      }
   else{
      every k := key(packages) do
        if \packages[k].vars then
           total +:= *packages[k].vars
      }  
   return total
end

#
# public method:
# returns a list of class names that are not in any package 
#
method getClasses(all)
   local cname, cls, names := []

   if /all then  cls := classes
   else          cls := classes ++ pkgclasses 
      
   if *cls > 0 then{
      every cname := !cls do
        push(names, cname)
      return sortf(names)
      }
   else 
      fail 
end

#
# public method:
# returns a list of class names used in the loaded program
#
method getClassMethods(cname)
   local mthd, i, j, names := [] 

   if \methods[cname] then{
      i := *cname + 1
      mthd := ?methods[cname]
      j := find(cname, mthd)
      every mthd := !methods[cname] do
         push(names, mthd[i+j:0])
      }
   return names
end

#
# public method:
# returns a list of all global variables used in the loaded program
#
method getGlobals()
   local var, names := [] 

   if *vglobals > 0 then{
      every var := !vglobals do
         push(names, var)
      return sortf(names)
      }
   else
      fail 
end

#
# public method:
# returns a list of all procedures used in the loaded program
#
method getProcedures()
   local p, names := [] 

   if *pglobals > 0 then{
      every p := !pglobals do
         push(names, p)
      return sortf(names)
      }
   else
      fail 
end

#
# public method:
# returns a list of all built-in functions used in the loaded program
#
method getFunctions()
   local f, names := [] 

   if *fglobals > 0 then{
      every f := !fglobals do
         push(names, f)
      return sortf(names)
      }
   else 
      fail
end

#
# public method:
# returns a list of all records used in the loaded program
#
method getRecords()
   local r, names := [] 

   if *records > 0 then{
      every r := !records do
         push(names, r)
      return sortf(names)
      }
   else
      fail
end

#
# Initialization
#
initially()

   vglobals    := set()
   pglobals    := set()
   fglobals    := set()
   records     := set()
   classes     := set()
   methods     := table()
   packages    := table()
   pkgclasses  := set()
end
